from dataclasses import dataclass
import discord
import re
import base64
import json
from discord.ext.commands import MemberConverter

def attempt_to_find_member(name: str, guild: discord.Guild):
    """
    Attempt to find a guild member by their display name.

    Handles various name formats and edge cases:
    - Display names with spaces, special characters, emojis
    - Nickname format
    - "Name (GlobalName)" format
    - Case-sensitive matching
    """
    # First try exact match on display_name (most common case)
    member = discord.utils.find(lambda m: m.display_name == name, guild.members)
    if member:
        return member

    # Try nickname (might be different from display_name in some cases)
    member = discord.utils.find(lambda m: m.nick and m.nick == name, guild.members)
    if member:
        return member

    # Try global_name
    member = discord.utils.find(lambda m: m.global_name and m.global_name == name, guild.members)
    if member:
        return member

    # Try username
    member = discord.utils.find(lambda m: m.name == name, guild.members)
    if member:
        return member

    # Try parsing "Name (GlobalName)" format that might be generated by parse_content
    pattern = r"^(.*?)\s+\((.*?)\)$"
    match = re.match(pattern, name)
    if match:
        potential_name = match.group(1).strip()
        potential_global = match.group(2).strip()

        # Try matching the first part as username
        member = discord.utils.find(
            lambda m: m.name == potential_name,
            guild.members
        )
        if member:
            return member

        # Try matching the first part as display_name
        member = discord.utils.find(
            lambda m: m.display_name == potential_name,
            guild.members
        )
        if member:
            return member

    return None

def parse_content(message: discord.Message):
    pattern = r"<@(\d+)>"

    def replace_match(match):
        user_id = int(match.group(1))
        member = message.guild.get_member(user_id)
        return f"<@{member}>"
    
    return re.sub(pattern, replace_match, message.content)


def parse_response(response: str, guild: discord.Guild):
    pattern = r"@?<@?([^>]+)>"

    def replace_match(match):
        display_name = match.group(1)
        member = attempt_to_find_member(display_name, guild)
        if not member: 
            return f"<@{display_name}>"

        return f"<@{member.id}>"
        
    return re.sub(pattern, replace_match, response)


class UserProfile:
    def __init__(self, user, info):
        self.user = user
        self.info = info

    def __str__(self) -> str:
        return f"{self.user}: {self.info}"
    
    def to_json(self) -> dict:
        obj = {
            "user": self.user,
            "info": self.info
        }
        return obj

@dataclass
class Image:
    data: str
    content_type: str

    @classmethod
    async def create(cls, attachment: discord.Attachment) -> "Image":
        image_str = base64.b64encode(await attachment.read(use_cached=True)).decode()
        
        return cls(image_str, attachment.content_type)

class Message:
    def __init__(self, msg: discord.Message, from_self: bool = False):
        self.author = msg.author
        if isinstance(self.author, discord.User):
            self.author = msg.guild.get_member(self.author.id)

        self.author = msg.author.display_name
        self.text = parse_content(msg)
        self.id = msg.id
        self.created_at = msg.created_at
        self.images: list[Image] = []
        self.from_self = from_self

    @classmethod
    async def create(cls, msg: discord.Message, from_self: bool = False) -> "Message":
        obj = cls(msg, from_self)

        for attachment in msg.attachments:
            if "image" in attachment.content_type:
                obj.images.append(await Image.create(attachment))
        return obj
    
    def __str__(self) -> str:
        return f"{self.author}: {self.text}"
    
    def to_json(self) -> dict:
        obj = {
            "message_id": self.id,
            "created_at": str(self.created_at),
            "author" : self.author,
            "content" : self.text,
        }
        return obj
    
    def to_chat_turns(self) -> list[dict]:
        objs = []

        if self.text:
            text_obj = {
                "type": "text",
                "text": json.dumps(self.to_json()) if not self.from_self else self.text,
            }
            objs.append(text_obj)

        for image in self.images:
            img_obj = {
                "type": "image",
                "source": {
                    "type": "base64",
                    "media_type": image.content_type,
                    "data": image.data,
                }
            }
            objs.append(img_obj)

        return objs
